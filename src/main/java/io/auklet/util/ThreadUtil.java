package io.auklet.util;

import edu.umd.cs.findbugs.annotations.NonNull;
import edu.umd.cs.findbugs.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;

/** <p>Utility methods related to thread management.</p> */
public final class ThreadUtil {

    private static final Logger LOGGER = LoggerFactory.getLogger(ThreadUtil.class);

    private ThreadUtil() {}

    /**
     * <p>Returns a thread factory that produces daemon threads.</p>
     *
     * @param nameFormat the name format for threads created by this factory. If {@code null},
     * thread names will be autogenerated by the JVM. If not {@code null}, you can use the placeholder
     * {@code %d} to substitute the thread number (auto-increments starting at 1).
     * @return never {@code null}.
     */
    @NonNull
    public static ThreadFactory createDaemonThreadFactory(@Nullable final String nameFormat) {
        return new ThreadFactory() {
            private final AtomicLong counter = new AtomicLong();
            @Override public Thread newThread(Runnable r) {
                Thread t = Executors.defaultThreadFactory().newThread(r);
                t.setDaemon(true);
                final long count = counter.incrementAndGet();
                if (nameFormat != null) t.setName(String.format(nameFormat, count));
                return t;
            }
        };
    }

    /**
     * <p>Shuts down the given executor service. If it does not shut down within 3 seconds,
     * or if the current thread is interrupted while waiting for shutdown to complete,
     * {@link ExecutorService#shutdownNow()} is invoked.</p>
     *
     * @param es no-op if {@code null}.
     */
    public static void shutdown(@Nullable ExecutorService es) {
        if (es == null) return;
        try {
            es.shutdown();
            if (!es.awaitTermination(3, TimeUnit.SECONDS)) es.shutdownNow();
        } catch (InterruptedException ie) {
            // End-users that call shutdown() explicitly should only do so inside the context of a JVM shutdown.
            // Thus, rethrowing this exception creates unnecessary noise and clutters the API/Javadocs.
            LOGGER.warn("Interrupted while awaiting ExecutorService shutdown.", ie);
            es.shutdownNow();
            Thread.currentThread().interrupt();
        } catch (SecurityException se) {
            LOGGER.warn("Could not shut down ExecutorService.", se);
        }
    }

}
